package com.diogo.oliveira.xmpp.stanza;

import com.diogo.oliveira.xmpp.connection.GcmPacketExtension;
import com.diogo.oliveira.xmpp.util.MessageType;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.jivesoftware.smack.SmackException;
import org.jivesoftware.smack.SmackException.NotConnectedException;
import org.jivesoftware.smack.StanzaListener;
import org.jivesoftware.smack.packet.Message;
import org.jivesoftware.smack.packet.Stanza;
import org.jivesoftware.smack.tcp.XMPPTCPConnection;
import org.json.simple.JSONValue;
import org.json.simple.parser.ParseException;

import static com.diogo.oliveira.xmpp.util.Constants.GCM_NAMESPACE;

/**
 * @author Diogo Oliveira
 * @date 04/11/2015 12:12:34
 */
public abstract class CCSStanzaListener implements StanzaListener
{
    private static final Logger LOGGER = Logger.getLogger(CCSStanzaListener.class.getName());
    protected volatile boolean connectionDraining = false;
    private XMPPTCPConnection connection;

    protected CCSStanzaListener getListener()
    {
        return this;
    }

    protected void setConnection(XMPPTCPConnection connection)
    {
        this.connection = connection;
    }

    @Override
    public void processPacket(Stanza stanza)
    {
        try
        {
            LOGGER.log(Level.WARNING, "************* 1 *************");

            //LOGGER.log(Level.INFO, "Recebido: {0}", stanza.toXML());
            Message message = (Message)stanza;
            LOGGER.log(Level.WARNING, "************* 2 *************");

            GcmPacketExtension gcmPacketExtension = (GcmPacketExtension)message.getExtension(GCM_NAMESPACE);
            LOGGER.log(Level.WARNING, "************* 3 *************");

            String json = gcmPacketExtension.getJson();
            LOGGER.log(Level.WARNING, "************* 4 *************");

            Map<String, Object> jsonObject = (Map<String, Object>)JSONValue.parseWithException(json);
            LOGGER.log(Level.WARNING, "************* 5 *************");

            LOGGER.log(Level.WARNING, "************* 6 *************");
            String XXX = String.valueOf(MessageType.get(jsonObject.get("message_type")));

            /* Presente para "ACK/NACK", ou null caso contrário */
            switch(MessageType.get(jsonObject.get("message_type")))
            {
                case NORMAL:
                {
                    LOGGER.log(Level.WARNING, "************* 7 *************");

                    /* Mensagem upstream normal */
                    processMessageUpstream(jsonObject);

                    /* Enviar ACK para CCS */
                    String messageId = (String)jsonObject.get("message_id");
                    String from = (String)jsonObject.get("from");
                    String ACK = createJsonACK(from, messageId);

                    try
                    {
                        send(ACK);
                    }
                    catch(SmackException.NotConnectedException ex)
                    {
                        LOGGER.log(Level.SEVERE, null, ex);
                    }
                    break;
                }
                case ACK:
                {
                    /* Processa mensagem ACK */
                    processReceiptACK(jsonObject);
                    break;
                }
                case NACK:
                {
                    /* Processa mensagem NACK */
                    processReceiptNACK(jsonObject);
                    break;
                }
                case CONTROL:
                {
                    /* Processa mensagem CONTROL */
                    processMessageControl(jsonObject);
                    break;
                }
                case UNRECOGNIZED:
                default:
                {
                    LOGGER.log(Level.WARNING, "Unrecognized message type (%s)", jsonObject.get("message_type").toString());
                    break;
                }
            }
        }
        catch(ParseException ex)
        {
            LOGGER.log(Level.SEVERE, null, ex);
        }
    }

    /**
     * Retorna um ID de mensagem aleatória para identificar exclusivamente uma mensagem.
     * <p>
     * <p>
     * Nota: This is generated by a pseudo random number generator for illustration purpose, and is not guaranteed to be unique.
     *
     * @return
     */
    public String nextMessageId()
    {
        return "msgid:" + UUID.randomUUID().toString();
    }

    /**
     * Envia uma mensagem jusante.
     *
     * @param jsonRequest Mensagem a ser enviada no formato json.
     *
     * @throws NotConnectedException
     */
    public void send(String jsonRequest) throws SmackException.NotConnectedException
    {
        connection.sendStanza(new GcmPacketExtension(jsonRequest).toPacket());
    }

    /**
     * Sends a downstream message to GCM.
     *
     * @param jsonRequest Mensagem a ser enviada no formato json.
     *
     * @return true if the message has been successfully sent.
     *
     * @throws NotConnectedException
     */
    public boolean sendDownstreamMessage(String jsonRequest) throws SmackException.NotConnectedException
    {
        if(!connectionDraining)
        {
            send(jsonRequest);
            return true;
        }

        LOGGER.info("Descartando mensagem a jusante uma vez que a conexão está draining.");
        return false;
    }

    /**
     * Cria uma mensagem de ACK JSON para uma mensagem upstream recebida de um aplicativo.
     *
     * @param to        registrationId do dispositivo que enviou a mensagem.
     * @param messageId messageId da mensagem.
     *
     * @return
     */
    public String createJsonACK(String to, String messageId)
    {
        Map<String, Object> message = new HashMap<>();
        message.put("message_type", "ack");
        message.put("to", to);
        message.put("message_id", messageId);

        /* REMOVER QUANDO RELEASE */
        LOGGER.info(JSONValue.toJSONString(message));

        return JSONValue.toJSONString(message);
    }

    /**
     * Cria uma mensagem JSON codificado.
     *
     * @param to             Dispositivo de destino (Obrigatório).
     * @param messageId      Único para o qual CCS irá enviar um "ACK/NACK" (Obrigatório).
     * @param payload        O conteúdo da mensagem pretendida para a aplicação (Opcional).
     * @param collapseKey    GCM parâmetro collapse_key (Opcional).
     * @param timeToLive     GCM time_to_live (Opcional).
     * @param delayWhileIdle GCM parâmetro delay_while_idle (Optional).
     *
     * @return JSON encoded GCM message.
     */
    public String createJsonMessage(String to, String messageId, Map<String, String> payload, String collapseKey, Long timeToLive, Boolean delayWhileIdle)
    {
        Map<String, Object> message = new HashMap<>();
        message.put("message_id", messageId);
        message.put("data", payload);
        message.put("to", to);

        if(collapseKey != null)
        {
            message.put("collapse_key", collapseKey);
        }
        if(timeToLive != null)
        {
            message.put("time_to_live", timeToLive);
        }
        if(delayWhileIdle != null && delayWhileIdle)
        {
            message.put("delay_while_idle", true);
        }

        return JSONValue.toJSONString(message);
    }

    /**
     * Puxador de mensagem a partir de um aplicativo do dispositivo.
     * <p>
     * <p>
     * Este servidor envia uma mensagem de eco de volta ao dispositivo. Subclasses deve substituir esse método para processar corretamente
     * as mensagens montante.
     *
     * @param jsonObject Mensagem a ser enviada no formato json.
     */
    protected void processMessageUpstream(Map<String, Object> jsonObject)
    {
        String category = (String)jsonObject.get("category");
        String from = (String)jsonObject.get("from");

        @SuppressWarnings("unchecked")
        Map<String, String> payload = (Map<String, String>)jsonObject.get("data");
        payload.put("ECHO", "Application: " + category);

        /* Enviar uma resposta ECHO de volta */
        String echo = createJsonMessage(from, nextMessageId(), payload,
                "echo:CollapseKey", null, false);

        try
        {
            sendDownstreamMessage(echo);
        }
        catch(SmackException.NotConnectedException e)
        {
            LOGGER.log(Level.WARNING, "Não conectado, mensagem de eco não é enviado", e);
        }
    }

    protected void processMessageControl(Map<String, Object> jsonObject)
    {
        LOGGER.log(Level.INFO, "handleControlMessage(): {0}", jsonObject);
        String controlType = (String)jsonObject.get("control_type");

        if("CONNECTION_DRAINING".equals(controlType))
        {
            connectionDraining = true;
        }
        else
        {
            LOGGER.log(Level.INFO, "Unrecognized control type: %s. This could happen ifnew features are " + "added to the CCS protocol.", controlType);
        }
    }

    /**
     * Trata uma mensagem ACK.
     * <p>
     * <p>
     * Registra uma mensagem INFO, mas subclasses poderia substituí-lo para tratar adequadamente ack.
     *
     * @param jsonObject Mensagem a ser enviada no formato json.
     */
    protected void processReceiptACK(Map<String, Object> jsonObject)
    {
        LOGGER.log(Level.INFO, "handleAckReceipt() from: {0}, messageId: {1}", new Object[]
        {
            (String)jsonObject.get("from"), (String)jsonObject.get("message_id")
        });
    }

    /**
     * Trata uma mensagem NACK.
     * <p>
     * <p>
     * Registra uma mensagem INFO, mas subclasses poderia substituí-lo para tratar adequadamente nack.
     *
     * @param jsonObject Mensagem a ser enviada no formato json.
     */
    protected void processReceiptNACK(Map<String, Object> jsonObject)
    {
        LOGGER.log(Level.INFO, "handleNackReceipt() from: {0}, messageId: {1}", new Object[]
        {
            (String)jsonObject.get("from"), (String)jsonObject.get("message_id")
        });
    }
}
